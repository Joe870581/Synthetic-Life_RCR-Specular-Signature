
'use client';

import React, { useEffect, useRef, useState, useCallback, Suspense } from 'react';
import { useFirebase, useCollection, useMemoFirebase } from '@/firebase';
import Link from 'next/link';
import { ArrowLeft, MapPin, Compass, Navigation2, Plus, X, Trash2, Zap, BrainCircuit, Users, Car, Loader2, Eye, Activity, Battery, CloudMoon, GitBranch, Radio, Satellite, ShieldCheck, GitCommit, Database, KeyRound, HardDrive, Wifi, Server, Laptop, Tablet, Watch, Smartphone, Power, Users as UsersIcon } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import maplibregl, { Map as MapLibreMap, Marker, Popup } from 'maplibre-gl';
import 'maplibre-gl/dist/maplibre-gl.css';
import * as turf from '@turf/turf';
import { motion, AnimatePresence } from 'framer-motion';
import { collection, addDoc, serverTimestamp, query, onSnapshot, deleteDoc, doc } from 'firebase/firestore';

// --- CONFIGURATION ---
const MAP_STYLE_URL = `https://api.maptiler.com/maps/019b74f9-a03d-7375-b5dc-c3df6ca32c41/style.json?key=H3NHWZtIAaZh5lIf4Tu2`;
const customStyles = `
#map { position: absolute; inset: 0; }
body, html { margin: 0; height: 100%; background: #020306; overflow: hidden; }
.maplibregl-popup-content { background: rgba(15,23,42,0.9); color: white; border-radius: 12px; padding: 12px; font-family: sans-serif; }
.marker-pulse { box-shadow: 0 0 0 0 rgba(59,130,246,0.7); animation: pulse 2s infinite; }
@keyframes pulse { 0% { box-shadow:0 0 0 0 rgba(59,130,246,0.7);} 70% { box-shadow:0 0 0 20px rgba(59,130,246,0);} 100% { box-shadow:0 0 0 0 rgba(59,130,246,0);} }
`;

// --- MAIN APP COMPONENT ---
function TravelPlannerContent() {
  const { firestore } = useFirebase();
  const [tripName, setTripName] = useState("World Explorer");
  const [stops, setStops] = useState(['Toronto, ON', 'Quebec City, QC']);
  const [currentRoute, setCurrentRoute] = useState(null);
  const [tripStats, setTripStats] = useState({ distance: 0, duration: '0h 0m', cost: 0 });
  const [isLoadingRoute, setIsLoadingRoute] = useState(false);
  const [activeStep, setActiveStep] = useState(1);
  const [assignedMembers, setAssignedMembers] = useState([]);

  const mapContainerRef = useRef(null);
  const mapRef = useRef<MapLibreMap | null>(null);
  const routeMarkersRef = useRef<Marker[]>([]);

  // Public points of interest from Firestore
  const publicPointsQuery = useMemoFirebase(() => firestore ? query(collection(firestore, 'public_map_points')) : null, [firestore]);
  const { data: publicPoints } = useCollection(publicPointsQuery);
  const publicMarkersRef = useRef<Marker[]>([]);

  const geocodeLocation = useCallback(async (location: string) => {
    try {
      const response = await fetch(`https://api.maptiler.com/geocoding/${encodeURIComponent(location)}.json?key=H3NHWZtIAaZh5lIf4Tu2`);
      if (!response.ok) throw new Error('Geocoding failed');
      const data = await response.json();
      if (data.features && data.features.length > 0) return data.features[0].center; // [lng, lat]
    } catch (error) { console.error("Geocoding error:", error); }
    return null;
  }, []);

  const reverseGeocode = useCallback(async (lng, lat) => {
    try {
      const response = await fetch(`https://api.maptiler.com/geocoding/v2/${lng},${lat}.json?key=H3NHWZtIAaZh5lIf4Tu2&language=en&types=place%2Cpoi`);
      const data = await response.json();
      if (data.features && data.features.length > 0) return data.features[0].text;
    } catch (error) { console.error("Reverse geocoding error:", error); }
    return "Custom Pin";
  }, []);

  const calculateRoute = useCallback(async () => {
    if (stops.length < 2) return;
    setIsLoadingRoute(true);

    const coordinates = await Promise.all(stops.map(stop => stop.trim() ? geocodeLocation(stop) : null));
    const validCoords = coordinates.filter(c => c !== null);

    // Clear old markers
    routeMarkersRef.current.forEach(marker => marker.remove());
    routeMarkersRef.current = [];

    // Add new markers for valid stops
    validCoords.forEach((coord, index) => {
      const el = document.createElement('div');
      el.className = `w-4 h-4 rounded-full border-2 border-white shadow-lg ${index === 0 ? 'bg-indigo-500' : index === validCoords.length - 1 ? 'bg-emerald-500' : 'bg-slate-500'}`;
      const marker = new Marker({ element: el }).setLngLat(coord).addTo(mapRef.current);
      routeMarkersRef.current.push(marker);
    });

    if (validCoords.length < 2) {
      setCurrentRoute(null);
      setIsLoadingRoute(false);
      return;
    }

    const coordsString = validCoords.map(c => c.join(',')).join(';');
    const routeUrl = `https://api.maptiler.com/routing/v1/driving/${coordsString}?overview=full&geometries=geojson&steps=false&key=H3NHWZtIAaZh5lIf4Tu2`;
    
    try {
      const response = await fetch(routeUrl);
      const data = await response.json();
      if (data.routes && data.routes.length > 0) {
        const route = data.routes[0];
        setCurrentRoute({ type: 'Feature', geometry: route.geometry, properties: {} });
        
        const distanceKm = route.distance / 1000;
        const durationHrs = route.duration / 3600;
        const fuelCost = (distanceKm / 10) * 1.50;
        setTripStats({ distance: distanceKm, duration: `${Math.floor(durationHrs)}h ${Math.round((durationHrs % 1) * 60)}m`, cost: fuelCost });

        if (mapRef.current) {
            const map = mapRef.current;
            const source = map.getSource('route');
            if (source) (source as maplibregl.GeoJSONSource).setData({ type: 'Feature', geometry: route.geometry, properties: {} });
            else {
                map.addSource('route', { type: 'geojson', data: { type: 'Feature', geometry: route.geometry, properties: {} } });
                map.addLayer({
                    id: 'route', type: 'line', source: 'route',
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: { 'line-color': '#3b82f6', 'line-width': 6, 'line-opacity': 0.8, 'line-blur': 1 }
                });
            }
            const bounds = new maplibregl.LngLatBounds(validCoords[0], validCoords[0]);
            for (const coord of validCoords) { bounds.extend(coord); }
            map.fitBounds(bounds, { padding: 100, duration: 1500 });
        }
      }
    } catch (error) { console.error("Routing error:", error); } 
    finally { setIsLoadingRoute(false); }
  }, [stops, geocodeLocation]);
  
  const addStop = () => setStops(prev => [...prev.slice(0, -1), '', prev.slice(-1)[0]]);
  const removeStop = (index) => setStops(prev => prev.filter((_, i) => i !== index));
  const updateStop = (index, value) => setStops(prev => prev.map((s, i) => i === index ? value : s));

  const suggestStops = async () => {
    if (stops.length < 2) return;
    const startCoords = await geocodeLocation(stops[0]);
    const endCoords = await geocodeLocation(stops[stops.length - 1]);
    if (!startCoords || !endCoords) return;

    const midPoint = turf.midpoint(turf.point(startCoords), turf.point(endCoords));
    const midName = await reverseGeocode(midPoint.geometry.coordinates[0], midPoint.geometry.coordinates[1]);
    
    setStops(prev => [prev[0], midName, prev[prev.length - 1]]);
  };
  
  const handleMapClick = async (e: maplibregl.MapMouseEvent) => {
    if (activeStep !== 2) return; // Only add stops in step 2
    const { lng, lat } = e.lngLat;
    const stopName = await reverseGeocode(lng, lat);
    setStops(prev => [...prev.slice(0, -1), stopName, prev[prev.length - 1]]);
  };

  const handleSavePublicPoint = async (e: maplibregl.MapMouseEvent) => {
      const { lng, lat } = e.lngLat;
      const title = prompt("Enter a title for this public pin:");
      if (!title || !firestore) return;
      
      await addDoc(collection(firestore, 'public_map_points'), {
          title,
          lng,
          lat,
          createdAt: serverTimestamp()
      });
  };

  useEffect(() => {
    if (!mapContainerRef.current || mapRef.current) return;
    
    mapRef.current = new MapLibreMap({ container: mapContainerRef.current, style: MAP_STYLE_URL, center: [-79.38, 43.65], zoom: 5 });
    mapRef.current.on('load', calculateRoute);
    mapRef.current.on('click', handleMapClick);
    mapRef.current.on('contextmenu', handleSavePublicPoint);

    return () => mapRef.current?.remove();
  }, [calculateRoute, handleMapClick, handleSavePublicPoint]);

  useEffect(() => {
    if (!mapRef.current || !publicPoints) return;
    
    // Clear old public markers
    publicMarkersRef.current.forEach(marker => marker.remove());
    publicMarkersRef.current = [];

    // Add new public markers
    publicPoints.forEach(point => {
        const el = document.createElement('div');
        el.className = 'w-3 h-3 bg-yellow-400 rounded-full border-2 border-black marker-pulse';
        el.title = point.title;
        const marker = new Marker({ element: el }).setLngLat([point.lng, point.lat]).addTo(mapRef.current);
        publicMarkersRef.current.push(marker);
    });
  }, [publicPoints]);

  const renderStepContent = () => {
    switch (activeStep) {
        case 1:
            return (
                <div className="space-y-4">
                    {stops.map((stop, i) => (
                         <div key={i} className="relative group">
                            <input value={stop} onChange={(e) => updateStop(i, e.target.value)} onBlur={calculateRoute} className="bg-slate-800/50 border border-white/10 p-4 rounded-xl w-full text-lg font-semibold placeholder-slate-500 focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="Set location..." />
                            {(i > 0 && i < stops.length -1) && <button onClick={() => removeStop(i)} className="absolute top-1/2 -translate-y-1/2 right-3 text-slate-500 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity"><Trash2 size={16}/></button>}
                         </div>
                    ))}
                    <Button variant="outline" className="w-full" onClick={() => setActiveStep(2)}>Next: Add Stops</Button>
                </div>
            );
        case 2:
            return (
                <div className="space-y-4">
                    <p className="text-center text-sm text-indigo-300">Click on the map to add a custom stop, or use AI. Right-click to add a public pin for everyone.</p>
                    <Button variant="outline" className="w-full" onClick={suggestStops}><Zap size={16}/> AI Suggest Stops</Button>
                    <Button className="w-full" onClick={() => setActiveStep(3)}>Next: Finalize</Button>
                </div>
            );
        case 3:
            return (
                <div className="space-y-4 text-center">
                    <h4 className="font-bold">Trip Ready</h4>
                    <p className="text-sm text-slate-400">Assign members and launch your mission.</p>
                     <div className="flex justify-center gap-2 py-2">
                        {[1, 2, 3, 4].map(i => <div key={i} className="w-12 h-12 rounded-full bg-slate-700" />)}
                    </div>
                    <Button className="w-full" onClick={() => setActiveStep(4)}>Launch Live Mission</Button>
                </div>
            );
        case 4:
            return <p>Launching...</p>;
        default: return null;
    }
  };
  
  if (activeStep === 4) {
    const encodedStops = encodeURIComponent(stops.join(','));
    const encodedTripName = encodeURIComponent(tripName);
    window.location.href = `/car/sandbox/${encodedTripName}?stops=${encodedStops}`;
    return <div className="h-full flex items-center justify-center text-white"><Loader2 className="animate-spin mr-2"/> Launching Live Mission...</div>;
  }

  return (
    <div className="flex h-screen overflow-hidden">
      <style>{customStyles}</style>
      <aside className="w-96 flex-shrink-0 bg-slate-900/50 backdrop-blur-sm border-r border-white/5 p-6 flex flex-col h-full">
        <header className="mb-8">
          <h1 className="text-2xl font-black text-white italic">NOMAD<span className="text-indigo-400">ELITE</span></h1>
          <p className="text-xs text-slate-500 font-bold uppercase tracking-widest">PUBLIC TRIP PLANNER V3</p>
        </header>

        <div className="flex items-center gap-2 mb-6">
            {[1, 2, 3, 4].map(step => (
                <div key={step} className={`flex-1 h-1 rounded-full transition-all duration-500 ${activeStep >= step ? 'bg-indigo-500' : 'bg-slate-700'}`} />
            ))}
        </div>
        
        <div className="flex-grow overflow-y-auto pr-2 space-y-2">
            <h3 className="font-bold text-slate-400 mb-2">Step {activeStep}: {activeStep===1 ? 'Set Route' : activeStep===2 ? 'Add Stops' : activeStep===3 ? 'Finalize' : 'Launch'}</h3>
            {renderStepContent()}
        </div>

        <div className="mt-6 pt-6 border-t border-white/10 grid grid-cols-3 gap-3">
          <div className="p-4 bg-slate-800/50 rounded-xl text-center"><p className="text-xs text-slate-400">Distance</p><p className="text-lg font-bold">{tripStats.distance.toFixed(0)}km</p></div>
          <div className="p-4 bg-slate-800/50 rounded-xl text-center"><p className="text-xs text-slate-400">Time</p><p className="text-lg font-bold">{tripStats.duration}</p></div>
          <div className="p-4 bg-slate-800/50 rounded-xl text-center"><p className="text-xs text-slate-400">Cost</p><p className="text-lg font-bold">${tripStats.cost.toFixed(2)}</p></div>
        </div>
      </aside>

      <main className="flex-1 flex flex-col p-6 overflow-hidden bg-black">
        <div ref={mapContainerRef} className="flex-1 rounded-2xl overflow-hidden bg-slate-900 border border-white/10 relative">
          {isLoadingRoute && <div className="absolute inset-0 bg-black/50 flex items-center justify-center z-50"><Loader2 className="animate-spin text-white"/></div>}
        </div>
      </main>
    </div>
  );
}

export default function SandboxTripPlanner() {
  return (
    <Suspense fallback={<div className="h-screen w-screen bg-black flex items-center justify-center text-white">Loading Trip Planner...</div>}>
      <TravelPlannerContent />
    </Suspense>
  );
}
