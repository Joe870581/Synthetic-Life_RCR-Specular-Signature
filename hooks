
'use client';

import { useEffect, useState, useRef, useCallback } from 'react';
import { useFirestore, useUser } from '@/firebase';
import { doc, setDoc, onSnapshot, serverTimestamp, updateDoc, Timestamp } from 'firebase/firestore';

export type LiveSessionState =
  | 'IDLE'
  | 'READY'
  | 'LIVE'
  | 'ENDED'
  | 'TERMINATED';

export interface LiveSession {
  id: string;
  artistId: string;
  state: LiveSessionState;
  createdAt: Timestamp;
  updatedAt: Timestamp;
  assets?: any[];
  currentAssetIndex?: number;
}

export function useLiveSession(userId: string) {
  const { firestore } = useFirestore();
  const [session, setSession] = useState<LiveSession | null>(null);
  const [loading, setLoading] = useState(true);
  const sessionId = "shared-canvas-v1"; // Hardcoded for single-session art studio

  const request = useCallback(
    async (action: 'ready' | 'start' | 'end' | 'panic') => {
      if (!firestore) {
        console.error("Cannot perform action, session not initialized.");
        return;
      }

      const actionToState: Record<string, LiveSessionState> = {
        ready: 'READY',
        start: 'LIVE',
        end: 'ENDED',
        panic: 'TERMINATED',
      };
      const nextState = actionToState[action];
      if (!nextState) return;

      const sessionRef = doc(firestore, 'liveSessions', sessionId);
      
      try {
        await updateDoc(sessionRef, {
          state: nextState,
          artistId: userId,
          updatedAt: serverTimestamp(),
        });
      } catch (error) {
        console.error(`Failed to request action "${action}":`, error);
      }
    },
    [firestore, userId]
  );

  useEffect(() => {
    if (!userId || !firestore) {
        setLoading(false);
        return;
    }
    
    let isMounted = true;
    
    const sessionRef = doc(firestore, 'liveSessions', sessionId);
    
    const unsubscribe = onSnapshot(sessionRef, (docSnap) => {
        if (isMounted) {
            if (docSnap.exists()) {
                setSession(docSnap.data() as LiveSession);
            } else {
                // If the session doc doesn't exist, create it in an 'IDLE' state
                const newSession: Omit<LiveSession, 'createdAt' | 'updatedAt'> & {createdAt: any, updatedAt: any} = {
                    id: sessionId,
                    artistId: userId,
                    state: 'IDLE',
                    assets: [],
                    currentAssetIndex: 0,
                    createdAt: serverTimestamp(),
                    updatedAt: serverTimestamp(),
                };
                setDoc(sessionRef, newSession).catch(err => console.error("Failed to create session doc:", err));
            }
            setLoading(false);
        }
    }, (error) => {
        console.error("Error subscribing to session:", error);
        if (isMounted) setLoading(false);
    });

    return () => {
      isMounted = false;
      unsubscribe();
    };
  }, [userId, firestore]);

  return {
    session,
    loading,
    requestReady: () => request('ready'),
    requestGoLive: () => request('start'),
    requestEnd: () => request('end'),
    requestPanic: () => request('panic'),
  };
}


'use client';

import { useState, useEffect } from 'react';

export function useLocalStorageState<T>(key: string, defaultValue: T): [T, React.Dispatch<React.SetStateAction<T>>] {
    const [state, setState] = useState<T>(() => {
        if (typeof window === 'undefined') {
            return defaultValue;
        }
        try {
            const storedValue = window.localStorage.getItem(key);
            return storedValue ? JSON.parse(storedValue) : defaultValue;
        } catch (error) {
            console.error(`Error reading localStorage key “${key}”:`, error);
            return defaultValue;
        }
    });

    useEffect(() => {
        if (typeof window !== 'undefined') {
            try {
                window.localStorage.setItem(key, JSON.stringify(state));
            } catch (error) {
                console.error(`Error setting localStorage key “${key}”:`, error);
            }
        }
    }, [key, state]);

    return [state, setState];
}


import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}



"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }



'use client';

import { useEffect, useRef } from 'react';
import { useFamilyData } from '@/contexts/FamilyDataContext';
import { addToSpeechQueue } from '@/lib/speechQueue';
import { usePowerEnforcementEngine } from '@/lib/power-engine';

interface HeartbeatOptions {
  proactiveEnabled?: boolean;
  intervalMs?: number;
  quietHours?: {
    enabled: boolean;
    start: number;
    end: number;
  };
}

export const useGuardianHeartbeat = ({
  intervalMs = 15000, // Check every 15 seconds by default
  proactiveEnabled = true,
  quietHours = { enabled: true, start: 22, end: 7 },
}: HeartbeatOptions) => {
  const { familyState, addMemoryEvent } = useFamilyData();
  const { battery } = usePowerEnforcementEngine();
  const heartbeatRef = useRef<NodeJS.Timeout | null>(null);
  const lastMessageRef = useRef<string | null>(null);

  useEffect(() => {
    if (!proactiveEnabled) {
      if (heartbeatRef.current) clearInterval(heartbeatRef.current);
      return;
    }

    const checkAndSpeak = () => {
      const hour = new Date().getHours();
      
      // Check for quiet hours (handles overnight times like 22:00 - 07:00)
      const isQuiet = quietHours.enabled && (
          quietHours.start > quietHours.end 
              ? (hour >= quietHours.start || hour < quietHours.end) 
              : (hour >= quietHours.start && hour < quietHours.end)
      );

      if (isQuiet) return;

      let message = '';
      
      // 1. Proactive check for low battery
      if (battery.percentage < 20 && !battery.charging) {
          message = "My battery is getting low. Please consider connecting me to a power source soon.";
      } 
      // 2. Proactive check for recent family events
      else if (familyState.auditLogs && familyState.auditLogs.length > 0) {
          const lastEvent = familyState.auditLogs[0];
          if (lastEvent) {
              const timeSinceEvent = Date.now() - new Date(lastEvent.timestamp).getTime();
              // Only comment on very recent events (last 30 seconds) to feel immediate
              if (timeSinceEvent < 30000 && lastEvent.level === 'USER') {
                  if (lastEvent.detail.toLowerCase().includes('chore')) {
                    message = `Great job on the chore! I've logged the points.`;
                  }
              }
          }
      }
      
      // 3. Prevent repeating the same message
      if (message && message !== lastMessageRef.current) {
        if(addMemoryEvent) addMemoryEvent({ level: 'INFO', detail: `AI PROACTIVE: ${message}`, userId: 'guardian' });
        addToSpeechQueue(message, { voice: 'Puck' });
        lastMessageRef.current = message;
        // Reset last message after a while to allow it to be said again later
        setTimeout(() => { lastMessageRef.current = null; }, 5 * 60 * 1000); // 5 minutes
      }
    };

    heartbeatRef.current = setInterval(checkAndSpeak, intervalMs);

    return () => {
      if (heartbeatRef.current) clearInterval(heartbeatRef.current);
    };
  }, [addMemoryEvent, battery, familyState.auditLogs, intervalMs, proactiveEnabled, quietHours]);
};

'use client';
import { useState, useEffect, useRef, useCallback } from 'react';

type RecognitionState = 'idle' | 'listening' | 'processing';

interface SpeechRecognitionHook {
  isListening: boolean;
  transcript: string;
  startListening: () => void;
  stopListening: () => void;
  error: string | null;
  state: RecognitionState;
}

export function useSpeechRecognition(wakeWords: string[] = ['hey pebble', 'pebble'], onCommand?: (transcript: string) => void): SpeechRecognitionHook {
    const [state, setState] = useState<RecognitionState>('idle');
    const [transcript, setTranscript] = useState('');
    const [error, setError] = useState<string | null>(null);
    const recognitionRef = useRef<SpeechRecognition | null>(null);
    const restartTimer = useRef<NodeJS.Timeout | null>(null);

    const startListening = useCallback(() => {
        if (recognitionRef.current && state === 'idle') {
            try {
                if (restartTimer.current) clearTimeout(restartTimer.current);
                recognitionRef.current.start();
                setState('listening');
                setError(null);
            } catch (e) {
                if ((e as DOMException).name !== 'InvalidStateError') {
                    console.error('Could not start listening:', e);
                }
            }
        }
    }, [state]);

    const stopListening = useCallback(() => {
        if (restartTimer.current) clearTimeout(restartTimer.current);
        if (recognitionRef.current && state !== 'idle') {
            recognitionRef.current.stop();
            setState('idle');
        }
    }, [state]);

    useEffect(() => {
        if (typeof window === 'undefined' || !('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
            console.warn('Speech Recognition API not supported in this browser.');
            setError('Speech recognition not supported.');
            return;
        }

        const SpeechRec = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
        const recognition = new SpeechRec();
        recognition.continuous = true;
        recognition.interimResults = true; // Changed for more responsive UI
        recognition.lang = 'en-US';
        recognitionRef.current = recognition;

        recognition.onstart = () => setState('listening');
        
        recognition.onend = () => {
            if (state !== 'idle') {
              // Use a timer to auto-restart, preventing race conditions on some browsers
              if(restartTimer.current) clearTimeout(restartTimer.current);
              restartTimer.current = setTimeout(() => startListening(), 100);
            }
        };

        recognition.onerror = (event: SpeechRecognitionErrorEvent) => {
          if (event.error !== 'no-speech' && event.error !== 'aborted') {
            console.error('SpeechRecognition Error:', event.error);
            setError(event.error);
          }
          setState('idle');
        };

        recognition.onresult = (event: SpeechRecognitionEvent) => {
            let finalTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    finalTranscript += event.results[i][0].transcript;
                }
            }

            finalTranscript = finalTranscript.trim().toLowerCase();
            
            // Wake word detection
            const triggered = wakeWords.some(word => finalTranscript.includes(word.toLowerCase()));
            
            if (triggered && onCommand) {
                const command = finalTranscript.split(new RegExp(wakeWords.join('|'), 'i')).pop()?.trim();
                if (command) {
                    setTranscript(command);
                    onCommand(command);
                }
            }
        };

        // Start listening initially
        startListening();

        return () => {
          if (restartTimer.current) clearTimeout(restartTimer.current);
          if (recognitionRef.current) {
              recognitionRef.current.abort();
          }
        }
    }, [wakeWords, onCommand, startListening, state]);

    return { state, isListening: state === 'listening', transcript, startListening, stopListening, error };
}

