
'use client';

import React, { Suspense } from 'react';
import { Toaster } from '@/components/ui/toaster';

// This layout ensures that the Art Studio page is wrapped
// with the necessary Firebase context provider.

export default function StudioLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    // The Suspense boundary is important for client-side providers.
    <Suspense fallback={<div className="h-screen w-screen bg-black flex items-center justify-center text-white">Loading Studio...</div>}>
        {children}
        <Toaster />
    </Suspense>
  );
}

'use client';

import React, { Suspense } from 'react';
import StudioClient from './studio-client';

// This is the main page component. It's a server component by default in Next.js App Router,
// but we add 'use client' because it will be wrapped by a client-side provider layout.
// Its only job is to render the actual client-side logic component.
export default function ArtStudioPage() {
  return (
    // Suspense is good practice for components with client-side data fetching or logic.
    <Suspense fallback={<div className="h-screen w-screen bg-gray-950 flex items-center justify-center text-white">Loading Studio Client...</div>}>
      <StudioClient />
    </Suspense>
  );
}


'use client';

import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import {
  Palette, Pen, Eraser, Undo, Redo, Save, Upload, Trash2, Maximize,
  MousePointer2, Highlighter, PaintBucket, Layers, Square, Circle, Minus, Plus, Eye, EyeOff,
  Wand2, Sparkles, Image as ImageIcon, Bot, BrainCircuit, Type, FileUp, Download, Send, User, X,
  Radio, Play, StopCircle, ShieldAlert, CheckCircle, Loader2
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Slider } from '@/components/ui/slider';
import { Card, CardContent } from '@/components/ui/card';
import { cn } from '@/lib/utils';
import { AnimatePresence, motion } from 'framer-motion';
import { useToast } from '@/hooks/use-toast';
import { useFirebase, useUser } from '@/firebase';
import { doc, setDoc, onSnapshot, updateDoc, collection, addDoc, deleteDoc, serverTimestamp } from 'firebase/firestore';
import { useLiveSession } from '@/hooks/use-live-session';

// --- Constants ---
const appId = 'art-studio-app';
const documentId = 'shared-canvas-v1'; // Using a single document for simplicity

// --- Debounce Utility ---
const debounce = (func, delay) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), delay);
  };
};

// --- Child Components ---

const ToolbarButton = ({ icon: Icon, isActive, onClick, tooltip }) => (
  <Button
    variant={isActive ? "secondary" : "ghost"}
    size="icon"
    className="w-12 h-12 text-gray-300 hover:bg-indigo-600/50 hover:text-white"
    onClick={onClick}
    title={tooltip}
  >
    <Icon />
  </Button>
);

const FloatingPanel = ({ title, icon: Icon, children, position = 'top-20 right-4', onClose = null }) => (
  <motion.div
    initial={{ opacity: 0, y: 20 }}
    animate={{ opacity: 1, y: 0 }}
    exit={{ opacity: 0, y: 20 }}
    drag
    dragMomentum={false}
    dragHandle=".drag-handle"
    className={`fixed z-20 w-72 bg-gray-800/80 backdrop-blur-md border border-indigo-500/30 rounded-xl shadow-2xl ${position}`}
  >
    <header className="drag-handle p-3 flex justify-between items-center border-b border-gray-700 cursor-move">
      <h3 className="text-sm font-bold text-indigo-300 flex items-center gap-2"><Icon className="w-4 h-4" />{title}</h3>
      {onClose && <button onClick={onClose} className="text-gray-400 hover:text-white"><X className="w-4 h-4" /></button>}
    </header>
    <div className="p-3">
      {children}
    </div>
  </motion.div>
);

// --- Studio Component ---

function Studio() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const { firestore, user: firebaseUser } = useFirebase();
  const { session, loading: isSessionLoading, requestReady, requestGoLive, requestEnd, requestPanic } = useLiveSession(firebaseUser?.uid);

  const [tool, setTool] = useState('pen');
  const [color, setColor] = useState('#FFFFFF');
  const [brushSize, setBrushSize] = useState(10);
  const [brushOpacity, setBrushOpacity] = useState(1);
  const isDrawing = useRef(false);
  const lastPos = useRef({ x: 0, y: 0 });
  const [history, setHistory] = useState<string[]>([]);
  const [historyIndex, setHistoryIndex] = useState(-1);

  const docRef = useMemo(() => {
    if (!firestore) return null;
    return doc(firestore, 'artifacts', appId, 'public', 'data', 'studioDocuments', documentId);
  }, [firestore]);

  const hexToRgba = (hex, alpha) => {
    let r = 0, g = 0, b = 0;
    if (hex.length === 4) { r = parseInt(hex[1] + hex[1], 16); g = parseInt(hex[2] + hex[2], 16); b = parseInt(hex[3] + hex[3], 16); }
    else if (hex.length === 7) { r = parseInt(hex.slice(1, 3), 16); g = parseInt(hex.slice(3, 5), 16); b = parseInt(hex.slice(5, 7), 16); }
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  };

  const currentBrushColor = useMemo(() => {
    if (tool === 'eraser') return '#0f172a'; // Match background color
    return hexToRgba(color, brushOpacity);
  }, [tool, color, brushOpacity]);

  const redrawCanvas = useCallback((dataUrl?: string) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const context = canvas.getContext('2d');
    const image = new Image();
    image.onload = () => {
      context.fillStyle = '#0f172a';
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.drawImage(image, 0, 0);
    };
    if (dataUrl) {
      image.src = dataUrl;
    } else {
      context.fillStyle = '#0f172a';
      context.fillRect(0, 0, canvas.width, canvas.height);
    }
  }, []);

  const saveToHistory = useCallback(debounce(async () => {
    if (!canvasRef.current || !docRef || session?.state !== 'LIVE') return;
    const dataUrl = canvasRef.current.toDataURL('image/png');
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(dataUrl);
    await setDoc(docRef, { history: newHistory }, { merge: true });
    setHistoryIndex(newHistory.length - 1);
  }, 500), [history, historyIndex, docRef, session?.state]);
  
  useEffect(() => {
    if (!docRef) return;
    const unsubscribe = onSnapshot(docRef, (docSnap) => {
      if (docSnap.exists()) {
        const data = docSnap.data();
        const remoteHistory = data.history || [];
        // Only update if remote history is different to prevent redraw loops
        if(JSON.stringify(remoteHistory) !== JSON.stringify(history)) {
          setHistory(remoteHistory);
          const newIndex = remoteHistory.length - 1;
          setHistoryIndex(newIndex);
          redrawCanvas(newIndex >= 0 ? remoteHistory[newIndex] : undefined);
        }
      }
    });
    return () => unsubscribe();
  }, [docRef, redrawCanvas, history]);

  const getCoords = (e) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };
    const rect = canvas.getBoundingClientRect();
    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
  };

  const startDrawing = (e) => {
    if (session?.state !== 'LIVE') return;
    isDrawing.current = true;
    const coords = getCoords(e);
    lastPos.current = coords;
    const context = canvasRef.current?.getContext('2d');
    if (context) {
        context.beginPath();
        context.moveTo(coords.x, coords.y);
    }
  };

  const draw = (e) => {
    if (!isDrawing.current || session?.state !== 'LIVE') return;
    const context = canvasRef.current?.getContext('2d');
    if (!context) return;
    
    context.lineWidth = brushSize;
    context.strokeStyle = currentBrushColor;
    context.lineCap = 'round';
    context.lineJoin = 'round';
    
    const currentCoords = getCoords(e);
    context.lineTo(currentCoords.x, currentCoords.y);
    context.stroke();
    lastPos.current = currentCoords;
  };

  const stopDrawing = () => {
    if (!isDrawing.current) return;
    isDrawing.current = false;
    canvasRef.current?.getContext('2d')?.closePath();
    saveToHistory();
  };
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const resizeCanvas = () => {
      const dataUrl = history[historyIndex];
      const container = canvas.parentElement;
      if (container) {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
      }
      redrawCanvas(dataUrl);
    };
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    return () => window.removeEventListener('resize', resizeCanvas);
  }, [history, historyIndex, redrawCanvas]);

  return (
    <div className="flex flex-col h-full bg-gray-950 text-white font-sans overflow-hidden">
        <main className="flex-grow relative bg-slate-900">
            <canvas
                ref={canvasRef}
                onMouseDown={startDrawing}
                onMouseMove={draw}
                onMouseUp={stopDrawing}
                onMouseLeave={stopDrawing}
                onTouchStart={startDrawing}
                onTouchMove={draw}
                onTouchEnd={stopDrawing}
                className="absolute inset-0 w-full h-full cursor-crosshair"
            />
        </main>
        <div className="absolute bottom-4 left-1/2 -translate-x-1/2 z-10">
          <Card className="bg-gray-800/80 backdrop-blur-md border border-indigo-500/50 shadow-2xl">
            <CardContent className="p-2 flex items-center gap-2">
              <ToolbarButton icon={Pen} isActive={tool === 'pen'} onClick={() => setTool('pen')} tooltip="Brush"/>
              <ToolbarButton icon={Eraser} isActive={tool === 'eraser'} onClick={() => setTool('eraser')} tooltip="Eraser"/>
              <div className="w-px h-8 bg-gray-600 mx-2" />
              <div className="flex flex-col gap-2 w-40">
                  <Slider min={1} max={150} step={1} value={[brushSize]} onValueChange={(v) => setBrushSize(v[0])} />
                  <Slider min={0} max={1} step={0.05} value={[brushOpacity]} onValueChange={(v) => setBrushOpacity(v[0])} />
              </div>
            </CardContent>
          </Card>
        </div>
        <div className="fixed bottom-24 left-1/2 -translate-x-1/2 z-10">
          <div className="bg-gray-800/80 backdrop-blur-md border border-red-500/50 shadow-2xl p-2 rounded-xl flex items-center gap-2">
            {isSessionLoading && <Loader2 className="w-5 h-5 animate-spin"/>}
            {session?.state === 'IDLE' && <Button onClick={requestReady} className="bg-green-600 hover:bg-green-500"><Play className="mr-2"/> Ready to Broadcast</Button>}
            {session?.state === 'READY' && <Button onClick={requestGoLive} className="bg-green-600 hover:bg-green-500"><Play className="mr-2"/> Go Live</Button>}
            {session?.state === 'LIVE' && (
              <div className="flex gap-2">
                 <div className="px-3 py-1.5 bg-red-600/20 text-red-300 font-bold text-xs rounded-md flex items-center gap-2 animate-pulse">
                     <Radio className="w-3 h-3"/> LIVE
                 </div>
                 <Button onClick={requestEnd} variant="destructive" size="sm">End Broadcast</Button>
                 <Button onClick={requestPanic} variant="destructive" size="icon" className="bg-red-900"><ShieldAlert className="w-4 h-4"/></Button>
              </div>
            )}
            {(session?.state === 'ENDED' || session?.state === 'TERMINATED') && (
                <div className="px-3 py-1.5 text-yellow-400 font-bold text-xs">Broadcast Ended</div>
            )}
          </div>
        </div>
        <AnimatePresence>
            <FloatingPanel key="palette-panel" title="Color Palette" icon={Palette} position="bottom-24 left-4" onClose={() => {}}>
                <div className="grid grid-cols-5 gap-2">
                   {['#FFFFFF', '#EF4444', '#F97316', '#FBBF24', '#34D399', '#3B82F6', '#8B5CF6', '#EC4899', '#000000'].map(c => (
                        <motion.div key={c} onClick={() => setColor(c)} className={cn("w-8 h-8 rounded-full cursor-pointer border-2", color === c ? 'border-white' : 'border-transparent')} style={{backgroundColor: c}} whileHover={{scale: 1.1}}/>
                    ))}
                    <input type="color" value={color} onChange={e => setColor(e.target.value)} className="w-8 h-8 rounded-full cursor-pointer bg-transparent border-none"/>
                </div>
            </FloatingPanel>
        </AnimatePresence>
    </div>
  );
}


export default function StudioClient() {
    const { isUserLoading } = useUser();
    
    if (isUserLoading) {
      return (
        <div className="flex h-full w-full items-center justify-center bg-slate-900">
          <p className="text-white animate-pulse">Initializing Firebase Services...</p>
        </div>
      );
    }
    
    return <Studio />;
}
