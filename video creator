
'use client';

import React, { useState, useEffect, useRef, useCallback, Suspense, useMemo } from 'react';
import { initializeApp, getApps, getApp } from 'firebase/app';
import { getFirestore, doc, setDoc, onSnapshot, serverTimestamp } from 'firebase/firestore';
import { getAuth, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
import { getStorage, ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { Mic, StopCircle, Play, Trash2, Download, Loader2, Video, Volume2, Upload, ChevronLeft, ChevronRight, Scissors, Ruler, Plus, Minus, MousePointer2, Layers, Key, UploadCloud, Folder, Sparkles, Music, Radio, Disc, Palette, Film, Gamepad2, Save, FileUp, Zap, Link as LinkIcon, Code } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

// --- Global Variables (Mandatory Canvas Environment) ---
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
const firebaseConfig = JSON.parse(firebaseConfigStr);
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// --- Constants ---
const PX_PER_SECOND_DEFAULT = 60;
const PX_PER_SECOND_MAX = 200;
const PX_PER_SECOND_MIN = 10;
const TRACK_HEIGHT_PX = 80;

// --- Mock Data ---
const initialClips = [
  { id: 'c1', trackId: 't1', name: 'Intro Shot', start: 0, duration: 5, color: 'bg-indigo-600', source: 'vault_123', type: 'video', thumbnail: 'https://images.unsplash.com/photo-1517849845537-4d257902454a?w=800&q=80', url: 'https://assets.mixkit.co/videos/preview/mixkit-girl-in-neon-lighting-in-the-city-at-night-21895-large.mp4' },
  { id: 'c2', trackId: 't1', name: 'Action Scene 1', start: 8, duration: 4, color: 'bg-red-600', source: 'vault_124', type: 'video', thumbnail: 'https://images.unsplash.com/photo-1550745165-9bc0b252726f?w=800&q=80', url: 'https://assets.mixkit.co/videos/preview/mixkit-fast-flying-through-a-colorful-sci-fi-tunnel-42903-large.mp4' },
  { id: 'c3', trackId: 't2', name: 'Background Music', start: 0, duration: 15, color: 'bg-green-600', source: 'vault_audio_1', type: 'audio', waveform: 'M0,50 Q25,20 50,50 T100,50', url: 'https://cdn.pixabay.com/download/audio/2022/11/22/audio_51b14a6de1.mp3' },
  { id: 'c4', trackId: 't1', name: 'Close Up', start: 15, duration: 3, color: 'bg-blue-600', source: 'vault_125', type: 'video', thumbnail: 'https://images.unsplash.com/photo-1507207611509-ec012433ff52?w=800&q=80', url: 'https://assets.mixkit.co/videos/preview/mixkit-a-girl-looking-at-the-camera-in-the-middle-of-nowhere-23334-large.mp4' },
];

const initialTracks = [
  { id: 't1', name: 'Video Layer 1', type: 'video', isMuted: false, isLocked: false },
  { id: 't2', name: 'Audio Track 1', type: 'audio', isMuted: false, isLocked: false },
  { id: 't3', name: 'VFX/Comp Layer', type: 'vfx', isMuted: true, isLocked: false },
];

const initialKeyframes = {
  c1: { opacity: [{ time: 0, value: 100 }, { time: 3, value: 50 }], zoom: [{ time: 0, value: 100 }, { time: 5, value: 150 }], },
  c2: { opacity: [{ time: 0, value: 100 }, { time: 1, value: 100 }], position: [{ time: 0, value: { x: 0, y: 0 } }, { time: 2, value: { x: 50, y: 50 } }], }
};

// Debounce function
const debounce = (func, delay) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), delay);
  };
};

// --- Firebase Hook ---
const useFirebase = () => {
  const [db, setDb] = useState(null);
  const [user, setUser] = useState(null);
  const [storage, setStorage] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);

  useEffect(() => {
    if (Object.keys(firebaseConfig).length === 0) {
      console.warn("Firebase config is empty. Running in mock mode.");
      setIsAuthReady(true);
      setUser({ uid: crypto.randomUUID() });
      return;
    }
    try {
      const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
      const firestore = getFirestore(app);
      const authentication = getAuth(app);

      setDb(firestore);
      setStorage(getStorage(app));

      const unsubscribe = onAuthStateChanged(authentication, async (user) => {
        if (user) {
          setUser(user);
        } else {
          try {
            if (initialAuthToken) await signInWithCustomToken(authentication, initialAuthToken);
            else await signInAnonymously(authentication);
          } catch (e) { console.error("Auth Fail", e); }
        }
        setIsAuthReady(true);
      });

      return () => unsubscribe();
    } catch (e) {
      console.error("Firebase Initialization Error:", e);
      setIsAuthReady(true);
    }
  }, []);

  return { db, user, storage, isAuthReady };
};

// --- Timeline & Clip Logic Hooks ---
const useAudioProject = (db, user) => {
  const projectDocId = useMemo(() => user ? `main_project_${user.uid}` : null, [user]);

  const saveProject = useCallback(async (currentClips, currentTracks) => {
      if (!db || !projectDocId) return;
      const projectRef = doc(db, 'artifacts', appId, 'public', 'data', 'videoProjects', projectDocId);
      const serializableData = {
          clips: currentClips,
          tracks: currentTracks
      };
      await setDoc(projectRef, { ...serializableData, lastUpdated: serverTimestamp() }, { merge: true });
  }, [db, projectDocId]);
  
  const subscribeToProject = useCallback((setClips, setTracks) => {
      if (!db || !projectDocId) return () => {};
      const projectRef = doc(db, 'artifacts', appId, 'public', 'data', 'videoProjects', projectDocId);
      const unsubscribe = onSnapshot(projectRef, docSnap => {
          if (docSnap.exists()) {
              const data = docSnap.data();
              if (data.clips) setClips(data.clips);
              if (data.tracks) setTracks(data.tracks);
          }
      });
      return unsubscribe;
  }, [db, projectDocId]);

  return { saveProject, subscribeToProject };
};

const usePlaybackEngine = (clips, setClips) => {
  const [playhead, setPlayhead] = useState({ time: 0, isPlaying: false });
  const videoRefs = useRef({});
  const audioRefs = useRef({});
  const animationFrameRef = useRef<number>();

  const debouncedSave = useMemo(() => debounce(() => {
    // This is where you would call a prop or context function to save.
    // For now, we just log it.
    console.log("Auto-saving project state...");
  }, 2000), []);


  const togglePlayback = () => {
    setPlayhead(prev => ({ ...prev, isPlaying: !prev.isPlaying }));
  };

  useEffect(() => {
    let lastTime = performance.now();

    const tick = (now: number) => {
      if (playhead.isPlaying) {
        const delta = (now - lastTime) / 1000;
        lastTime = now;

        setPlayhead(prev => {
          const maxTime = Math.max(...clips.map(c => c.start + c.duration), 30);
          if (prev.time + delta >= maxTime) {
            return { ...prev, time: maxTime, isPlaying: false };
          }
          return { ...prev, time: prev.time + delta };
        });
      }
      animationFrameRef.current = requestAnimationFrame(tick);
    };

    animationFrameRef.current = requestAnimationFrame(tick);

    return () => cancelAnimationFrame(animationFrameRef.current);
  }, [playhead.isPlaying, clips]);

  useEffect(() => {
    clips.forEach(clip => {
      const mediaEl = clip.type === 'video' ? videoRefs.current[clip.id] : audioRefs.current[clip.id];
      if (!mediaEl) return;

      const localTime = playhead.time - clip.start;
      const isClipActive = localTime >= 0 && localTime <= clip.duration;

      if (isClipActive) {
        if (Math.abs(mediaEl.currentTime - localTime) > 0.15) {
          mediaEl.currentTime = localTime;
        }
        if (playhead.isPlaying && mediaEl.paused) {
          mediaEl.play().catch(e => console.error("Playback error:", e));
        } else if (!playhead.isPlaying && !mediaEl.paused) {
          mediaEl.pause();
        }
      } else {
        if (!mediaEl.paused) {
          mediaEl.pause();
        }
      }
    });

    const activeVideoClip = clips.find(c => c.type === 'video' && playhead.time >= c.start && playhead.time < c.start + c.duration);
    const previewVideo = document.getElementById('preview-video') as HTMLVideoElement;
    if (previewVideo) {
      if (activeVideoClip) {
        if (previewVideo.src !== activeVideoClip.url) {
          previewVideo.src = activeVideoClip.url;
        }
        const localTime = playhead.time - activeVideoClip.start;
        if (Math.abs(previewVideo.currentTime - localTime) > 0.15) {
          previewVideo.currentTime = localTime;
        }
        if (playhead.isPlaying && previewVideo.paused) {
          previewVideo.play().catch(e => {});
        } else if (!playhead.isPlaying && !previewVideo.paused) {
          previewVideo.pause();
        }
      } else {
        if (!previewVideo.paused) previewVideo.pause();
      }
    }

  }, [playhead.time, playhead.isPlaying, clips]);

  return { playhead, setPlayhead, videoRefs, audioRefs, togglePlayback };
};

const StudioBootOverlay = () => (
  <div className="fixed inset-0 z-[9999] bg-black flex flex-col items-center justify-center animate-in fade-in duration-700">
    <div className="text-center space-y-8">
      <div className="relative">
        <div className="w-24 h-24 mx-auto rounded-full bg-indigo-600/10 border border-indigo-500/30 flex items-center justify-center shadow-[0_0_50px_rgba(79,70,229,0.3)]">
          <Zap className="w-10 h-10 text-indigo-400 animate-pulse" />
        </div>
      </div>
      <div className="space-y-2">
        <h1 className="text-3xl font-black tracking-[0.2em] uppercase italic text-white">Sovereign<span className="text-indigo-500">Studio</span></h1>
        <div className="flex items-center justify-center space-x-3 text-[10px] font-mono text-indigo-400/60 tracking-[0.5em]">
          <span>SYSTEM ONLINE Â· REALTIME ENGINE</span>
        </div>
      </div>
    </div>
  </div>
);

const PreviewCanvas = React.memo(() => {
    return (
        <div className="w-full h-full bg-black flex flex-col justify-center items-center relative rounded-lg overflow-hidden shadow-2xl">
            <video id="preview-video" className="w-full h-full object-contain" muted />
        </div>
    );
});
PreviewCanvas.displayName = "PreviewCanvas";

const AudioWaveform = React.memo(({ waveform }) => {
    return (
        <svg className="w-full h-full absolute top-0 left-0 opacity-75 pointer-events-none" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path d={waveform} fill="rgba(255,255,255,0.2)" stroke="rgba(255,255,255,0.5)" strokeWidth="1" vectorEffect="non-scaling-stroke"/>
        </svg>
    );
});
AudioWaveform.displayName = "AudioWaveform";
  
const ClipComponent = React.memo(({ clip, zoomLevel, startDrag, startTrim, selected, trackType, handleClipClick }) => {
    const width = clip.duration * zoomLevel;
    const left = clip.start * zoomLevel;
    const isAudio = trackType === 'audio';

    return (
      <div
        draggable
        className="absolute rounded-lg cursor-pointer transition-all duration-150 ease-out flex items-center justify-center overflow-hidden group"
        style={{
          left: `${left}px`, width: `${width}px`, height: `${TRACK_HEIGHT_PX - 20}px`, top: '10px',
          backgroundColor: clip.color,
          boxShadow: `0 4px 15px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.1)`,
          border: selected ? '2px solid #ff7f50' : '1px solid rgba(0,0,0,0.2)',
          zIndex: selected ? 20 : 10,
        }}
        onClick={(e) => handleClipClick(e, clip.id)}
        onDragStart={(e) => startDrag(e, clip)}
      >
        <span className="text-xs font-semibold text-white/80 select-none truncate px-2">{clip.name}</span>
        {isAudio && clip.waveform && <AudioWaveform waveform={clip.waveform}/>}

        <span className="absolute left-1 bottom-0 text-[10px] font-mono text-white/70 bg-black/50 px-1 rounded-sm">
            {clip.start.toFixed(1)}s
        </span>
        <span className="absolute right-1 bottom-0 text-[10px] font-mono text-white/70 bg-black/50 px-1 rounded-sm">
            {(clip.start + clip.duration).toFixed(2)}s
        </span>
        
        {selected && (
          <>
            <div data-trimmer="left" onMouseDown={(e) => startTrim(e, clip, 'left')} onTouchStart={(e) => startTrim(e, clip, 'left')} className="absolute left-0 top-0 bottom-0 w-4 cursor-ew-resize bg-white/20 hover:bg-[#ff7f50] transition-colors rounded-l-lg z-30 opacity-80" />
            <div data-trimmer="right" onMouseDown={(e) => startTrim(e, clip, 'right')} onTouchStart={(e) => startTrim(e, clip, 'right')} className="absolute right-0 top-0 bottom-0 w-4 cursor-ew-resize bg-white/20 hover:bg-[#ff7f50] transition-colors rounded-r-lg z-30 opacity-80" />
          </>
        )}
      </div>
    );
});
ClipComponent.displayName = 'ClipComponent';
  
const TimelineRuler = React.memo(({ maxTime, playhead, zoomLevel }) => {
    const secondsToTimecode = (s) => {
        const mins = Math.floor(s / 60);
        const secs = Math.floor(s % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };
    const marks = useMemo(() => {
        const tickInterval = zoomLevel > 75 ? 1 : (zoomLevel > 20 ? 5 : 10);
        const numMarks = Math.ceil(maxTime / tickInterval);
        return Array.from({ length: numMarks + 1 }, (_, i) => i * tickInterval);
    }, [maxTime, zoomLevel]);

    return (
        <div className="h-8 bg-gray-800 flex items-center relative px-2 overflow-hidden border-b border-gray-700/50 select-none">
            <div className="h-full relative" style={{ width: `${maxTime * zoomLevel}px` }}>
                {marks.map((time) => {
                    const left = time * zoomLevel;
                    return (
                        <div key={time} className="absolute h-full pointer-events-none" style={{ left: `${left}px` }}>
                            <div className="w-px h-full bg-gray-700" />
                            <span className="absolute -top-1 -translate-x-1/2 text-[10px] text-gray-400 font-mono">
                                {secondsToTimecode(time)}
                            </span>
                        </div>
                    );
                })}
            </div>
        </div>
    );
});
TimelineRuler.displayName = 'TimelineRuler';

const MediaVault = ({ onUploadClick, media, onDragStart }) => (
    <div className="h-full bg-gray-900 border-l border-gray-700 p-3 flex flex-col space-y-4">
      <h3 className="font-bold text-lg text-white px-2">Media Vault</h3>
      <Button onClick={onUploadClick} className="w-full">
        <UploadCloud className="w-4 h-4 mr-2" /> Upload Media
      </Button>
      <div className="flex-1 space-y-2 overflow-y-auto pr-1">
        {media.map((item, index) => (
          <div 
            key={item.id || index} 
            draggable 
            onDragStart={(e) => onDragStart(e, item)}
            className="p-2 bg-gray-800 rounded-lg flex items-center gap-3 cursor-grab active:cursor-grabbing border border-gray-700"
          >
            <div className="w-16 h-10 bg-gray-700 rounded-md overflow-hidden relative">
              {item.thumbnail && <img src={item.thumbnail} alt={item.name} className="w-full h-full object-cover" />}
              <div className="absolute inset-0 bg-gradient-to-t from-black/50 to-transparent" />
              <Play className="absolute bottom-1 left-1 w-3 h-3 text-white/70" />
            </div>
            <div className="overflow-hidden">
              <p className="text-xs font-semibold truncate">{item.name}</p>
              <p className="text-[10px] text-gray-400">{item.duration.toFixed(2)}s</p>
            </div>
          </div>
        ))}
        {media.length === 0 && <p className="text-xs text-center text-gray-500 p-4">Your vault is empty. Upload some media!</p>}
      </div>
    </div>
);

const KeyframeEditor = ({ selectedClip, keyframes, setKeyframes }) => {
  if (!selectedClip) return <div className="p-4 text-center text-gray-500">Select a clip to edit keyframes.</div>;
  return <div className="space-y-4 text-gray-200"><h3 className="text-lg font-semibold text-yellow-400">Keyframe Animation</h3></div>;
};

const VfxPanel = ({ clip, userId }) => {
  if (!clip) return <div className="p-4 text-center text-gray-500">Select a clip for VFX.</div>;
  return (
    <div className="space-y-4 p-4 text-gray-200">
      <h3 className="text-lg font-semibold text-cyan-400">Real VFX Panels</h3>
      <Link href={`/shared-app/audio-studio?userId=${userId}`} passHref>
        <Button variant="outline" className="w-full border-cyan-500/50 text-cyan-400 hover:bg-cyan-500/10 hover:text-cyan-300">
          <Music className="w-4 h-4 mr-2"/>
          Create Your Own
        </Button>
      </Link>
    </div>
  );
};

const CompositorPanel = ({ clip }) => {
  if (!clip) return <div className="p-4 text-center text-gray-500">Select a clip for Composition.</div>;
  return <div className="space-y-4 p-4 text-gray-200"><h3 className="text-lg font-semibold text-pink-400">Layer Compositor</h3></div>;
};


const VideoCreatorPage = () => {
  const [booting, setBooting] = useState(true);
  const [activeTab, setActiveTab] = useState('keyframes');
  const [zoomLevel, setZoomLevel] = useState(PX_PER_SECOND_DEFAULT);
  const [tracks, setTracks] = useState(initialTracks);
  const [clips, setClips] = useState(initialClips);
  const [keyframes, setKeyframes] = useState(initialKeyframes);
  const [selectedClip, setSelectedClip] = useState(null);
  
  const { playhead, setPlayhead, videoRefs, audioRefs, togglePlayback } = usePlaybackEngine(clips, setClips);

  const dragState = useRef(null);

  const handleClipClick = (e, clipId) => {
    e.stopPropagation();
    setSelectedClip(clips.find(c => c.id === clipId));
  };
  
  const startDrag = (e, clip) => {
    e.dataTransfer.setData('application/json', JSON.stringify(clip));
    dragState.current = {
      clipId: clip.id,
      startX: e.clientX,
      startLeft: clip.start * zoomLevel,
      initialStart: clip.start,
    };
  };

  const startTrim = (e, clip, handle) => {
    e.stopPropagation();
    dragState.current = {
      clipId: clip.id,
      handle,
      startX: e.clientX,
      initialStart: clip.start,
      initialDuration: clip.duration,
    };
  };

  const handleMouseMove = useCallback((e) => {
    if (!dragState.current) return;

    const dx = e.clientX - dragState.current.startX;
    const timeDelta = dx / zoomLevel;

    setClips(prev => prev.map(c => {
      if (c.id !== dragState.current.clipId) return c;
      const newClip = { ...c };
      if (dragState.current.handle === 'left') {
        const newStart = Math.max(0, dragState.current.initialStart + timeDelta);
        const durationChange = c.start - newStart;
        newClip.start = newStart;
        newClip.duration = Math.max(0.5, c.duration + durationChange);
      } else if (dragState.current.handle === 'right') {
        newClip.duration = Math.max(0.5, dragState.current.initialDuration + timeDelta);
      } else {
        newClip.start = Math.max(0, dragState.current.initialStart + timeDelta);
      }
      return newClip;
    }));
  }, [zoomLevel]);

  const handleMouseUp = useCallback(() => {
    dragState.current = null;
  }, []);

  const handleDrop = (e, trackId) => {
    e.preventDefault();
    const timeline = e.currentTarget.getBoundingClientRect();
    const dropPosition = (e.clientX - timeline.left) / zoomLevel;
    const clipData = JSON.parse(e.dataTransfer.getData('application/json'));

    setClips(prev => {
        if(prev.find(c => c.id === clipData.id)) { // Move existing clip
            return prev.map(c => c.id === clipData.id ? {...c, trackId, start: dropPosition } : c);
        }
        return [...prev, { ...clipData, id: `clip_${Date.now()}`, trackId, start: dropPosition }];
    });
  };

  const maxTimelineTime = useMemo(() => {
    return Math.max(30, ...clips.map(c => c.start + c.duration));
  }, [clips]);
  
  useEffect(() => {
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [handleMouseMove, handleMouseUp]);
  
  useEffect(() => {
    const timer = setTimeout(() => setBooting(false), 1500);
    return () => clearTimeout(timer);
  }, []);
  
  if (booting) return <StudioBootOverlay />;

  return (
    <div className="h-full w-full bg-gray-950 flex flex-col overflow-hidden">
      {clips.map(clip => {
        if(clip.type === 'video') {
            return <video key={clip.id} ref={el => videoRefs.current[clip.id] = el} src={clip.url} muted playsInline style={{display: 'none'}} />
        }
        if(clip.type === 'audio') {
            return <audio key={clip.id} ref={el => audioRefs.current[clip.id] = el} src={clip.url} style={{display: 'none'}} />
        }
        return null;
      })}

      <header className="h-14 flex items-center justify-between px-4 border-b border-gray-800 flex-shrink-0">
        <h1 className="font-bold tracking-wide">Sovereign Studio</h1>
        <div className="flex items-center gap-4">
          <Button onClick={togglePlayback} className="w-24">
            {playhead.isPlaying ? <><StopCircle className="mr-2"/>Stop</> : <><Play className="mr-2"/>Play</>}
          </Button>
          <div className="flex items-center gap-2 text-xs font-mono text-cyan-400">
            <span>{playhead.time.toFixed(2)}s</span>
            <span>/</span>
            <span>{maxTimelineTime.toFixed(2)}s</span>
          </div>
        </div>
      </header>

      <div className="flex flex-1 overflow-hidden">
        <div className="flex flex-col flex-1">
          <div className="h-[55%] p-4">
             <PreviewCanvas />
          </div>
          <div className="flex-1 overflow-auto bg-gray-900 border-t border-gray-800" onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onTouchMove={handleMouseMove} onTouchEnd={handleMouseUp}>
            <TimelineRuler maxTime={maxTimelineTime} playhead={playhead} zoomLevel={zoomLevel} />
            <div className="relative">
              {tracks.map((track) => (
                <div key={track.id} className="relative border-b border-gray-800" style={{ height: `${TRACK_HEIGHT_PX}px` }} onDragOver={e => e.preventDefault()} onDrop={(e) => handleDrop(e, track.id)}>
                   <div className="absolute top-2 left-2 text-xs font-bold text-gray-500 bg-gray-900/50 px-2 py-1 rounded">{track.name}</div>
                   {clips.filter(c => c.trackId === track.id).map(clip => (
                      <ClipComponent key={clip.id} clip={clip} zoomLevel={zoomLevel} startDrag={startDrag} startTrim={startTrim} selected={selectedClip?.id === clip.id} trackType={track.type} handleClipClick={handleClipClick} />
                   ))}
                </div>
              ))}
              <div className="absolute top-0 bottom-0 w-px bg-yellow-400 pointer-events-none" style={{ left: `${playhead.time * zoomLevel}px` }} />
            </div>
          </div>
        </div>

        <aside className="w-[320px] border-l border-gray-800 flex flex-col">
            <MediaVault onUploadClick={() => {}} media={initialClips} onDragStart={startDrag} />
            <div className="border-t border-gray-800">
                <div className="flex border-b border-gray-800">
                    <button onClick={() => setActiveTab('keyframes')} className={`flex-1 p-2 text-xs font-bold ${activeTab === 'keyframes' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}>Keyframes</button>
                    <button onClick={() => setActiveTab('vfx')} className={`flex-1 p-2 text-xs font-bold ${activeTab === 'vfx' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}>VFX</button>
                    <button onClick={() => setActiveTab('compositor')} className={`flex-1 p-2 text-xs font-bold ${activeTab === 'compositor' ? 'bg-gray-700 text-white' : 'text-gray-400'}`}>Compositor</button>
                </div>
                 <div className="p-2 overflow-y-auto">
                    {activeTab === 'keyframes' && <KeyframeEditor selectedClip={selectedClip} keyframes={keyframes} setKeyframes={setKeyframes}/>}
                    {activeTab === 'vfx' && <VfxPanel clip={selectedClip} userId={user?.uid}/>}
                    {activeTab === 'compositor' && <CompositorPanel clip={selectedClip}/>}
                </div>
            </div>
        </aside>
      </div>
    </div>
  );
};

const App = () => (
  <Suspense fallback={<div className="h-screen w-screen bg-black flex items-center justify-center"><Loader2 className="animate-spin text-indigo-500" /></div>}>
    <VideoCreatorPage />
  </Suspense>
);

export default App;
